#include <iostream>
#include <string>
using namespace std;

struct Nodo {
    int id;
    string nombre;
    int nacimiento;
    string fallecimiento;
    Nodo* izq;
    Nodo* der;
    Nodo* padre;
};

Nodo* raiz = NULL;

// Crear nuevo nodo
Nodo* crearNodo(int id, string nombre, int nacimiento, string fallecimiento) {
    Nodo* nuevo = new Nodo;
    nuevo->id = id;
    nuevo->nombre = nombre;
    nuevo->nacimiento = nacimiento;
    nuevo->fallecimiento = fallecimiento;
    nuevo->izq = nuevo->der = nuevo->padre = NULL;
    return nuevo;
}

// Insertar miembro
void insertarFlexible(Nodo*& raiz, Nodo* nuevo) { //NO CAMBIAR - DAYANA
    if (!raiz) {
        raiz = nuevo;
        cout << "Primer miembro insertado como raíz.\n";
        return;
    }

    int idRelacionado;
    cout << "Ingrese el ID del familiar relacionado: ";
    cin >> idRelacionado;
    Nodo* relativo = buscar(raiz, idRelacionado);

    if (!relativo) {
        cout << "Miembro no encontrado.\n";
        return;
    }

    cout << "¿Qué relación tiene con " << relativo->nombre << "?\n";
    cout << "1. Padre/Madre\n";
    cout << "2. Hijo/a izquierdo/a\n";
    cout << "3. Hijo/a derecho/a\n";
    cout << "4. Hermano/a izquierdo/a\n";
    cout << "5. Hermano/a derecho/a\n";
    cout << "Opción: ";
    int relacion;
    cin >> relacion;

    switch (relacion) {
        case 1:
            if (relativo == raiz) {
                nuevo->izq = raiz;
                raiz->padre = nuevo;
                raiz = nuevo;
            } else {
                Nodo* padreAnt = relativo->padre;
                nuevo->padre = padreAnt;
                relativo->padre = nuevo;
                if (padreAnt) {
                    if (padreAnt->izq == relativo) padreAnt->izq = nuevo;
                    else padreAnt->der = nuevo;
                }
                nuevo->izq = relativo;
            }
            cout << "Asignado como padre/madre.\n";
            break;
        case 2:
            if (!relativo->izq) {
                relativo->izq = nuevo;
                nuevo->padre = relativo;
                cout << "Asignado como hijo izquierdo.\n";
            } else cout << "Ya tiene hijo izquierdo.\n";
            break;
        case 3:
            if (!relativo->der) {
                relativo->der = nuevo;
                nuevo->padre = relativo;
                cout << "Asignado como hijo derecho.\n";
            } else cout << "Ya tiene hijo derecho.\n";
            break;
        case 4:
        case 5:
            if (!relativo->padre) {
                cout << "No tiene padre registrado, no se puede agregar hermano.\n";
                break;
            }
            if (relacion == 4 && (!relativo->padre->izq || relativo->padre->izq == relativo)) {
                relativo->padre->izq = nuevo;
                nuevo->padre = relativo->padre;
                cout << "Asignado como hermano izquierdo.\n";
            } else if (relacion == 5 && (!relativo->padre->der || relativo->padre->der == relativo)) {
                relativo->padre->der = nuevo;
                nuevo->padre = relativo->padre;
                cout << "Asignado como hermano derecho.\n";
            } else {
                cout << "Ya existe un hijo en esa posición.\n";
            }
            break;
        default:
            cout << "Relación no válida.\n";
    }
}

// Buscar miembro por ID
Nodo* buscar(Nodo* actual, int id) {
    if (actual == NULL || actual->id == id) return actual;
    return (id < actual->id) ? buscar(actual->izq, id) : buscar(actual->der, id);
}

// Mínimo del subárbol
Nodo* minimo(Nodo* actual) {
    while (actual && actual->izq != NULL)
        actual = actual->izq;
    return actual;
}

// Eliminar nodo
Nodo* eliminar(Nodo* raiz, int id) {
    if (!raiz) return NULL;
    if (id < raiz->id) {
        raiz->izq = eliminar(raiz->izq, id);
    } else if (id > raiz->id) {
        raiz->der = eliminar(raiz->der, id);
    } else {
        // Nodo encontrado
        if (!raiz->izq) {
            Nodo* temp = raiz->der;
            delete raiz;
            return temp;
        } else if (!raiz->der) {
            Nodo* temp = raiz->izq;
            delete raiz;
            return temp;
        } else {
            Nodo* sucesor = minimo(raiz->der);
            raiz->id = sucesor->id;
            raiz->nombre = sucesor->nombre;
            raiz->nacimiento = sucesor->nacimiento;
            raiz->fallecimiento = sucesor->fallecimiento;
            raiz->der = eliminar(raiz->der, sucesor->id);
        }
    }
    return raiz;
}

// Recorridos
void inorden(Nodo* nodo) {
    if (!nodo) return;
    inorden(nodo->izq);
    cout << nodo->nombre << " (" << nodo->id << ")\n";
    inorden(nodo->der);
}

void preorden(Nodo* nodo) {
    if (!nodo) return;
    cout << nodo->nombre << " (" << nodo->id << ")\n";
    preorden(nodo->izq);
    preorden(nodo->der);
}

void postorden(Nodo* nodo) {
    if (!nodo) return;
    postorden(nodo->izq);
    postorden(nodo->der);
    cout << nodo->nombre << " (" << nodo->id << ")\n";
}

void porNiveles(Nodo* raiz) {
    if (raiz == NULL) return;

    const int MAX = 100;
    Nodo* cola[MAX];
    int inicio = 0, fin = 0;

    // Encolar raíz
    cola[fin++] = raiz;

    while (inicio < fin) {
        Nodo* actual = cola[inicio++]; // Desencolar

        cout << actual->nombre << " (" << actual->id << ")\n";

        // Encolar hijos
        if (actual->izq != NULL) {
            cola[fin++] = actual->izq;
        }
        if (actual->der != NULL) {
            cola[fin++] = actual->der;
        }
    }
}

// Ancestros
void mostrarAncestros(Nodo* nodo) {
    while (nodo) {
        cout << nodo->nombre << " (" << nodo->id << ")\n";
        nodo = nodo->padre;
    }
}

// Descendientes (en preorden)
void mostrarDescendientes(Nodo* nodo) {
    if (!nodo) return;
    cout << nodo->nombre << " (" << nodo->id << ")\n";
    mostrarDescendientes(nodo->izq);
    mostrarDescendientes(nodo->der);
}

// Menú principal
int main() {
	int generaciones; //NO CAMBIAR - DAYANA
    cout << "Ingrese cuántos miembros desea agregar al árbol genealógico: ";
    cin >> generaciones;
    
    int opcion;
    do {
        cout << "\n---- MENU ÁRBOL GENEALÓGICO ----\n";
        cout << "1. Insertar miembro\n";
        cout << "2. Buscar miembro\n";
        cout << "3. Eliminar miembro\n";
        cout << "4. Consultar ancestros\n";
        cout << "5. Consultar descendientes\n";
        cout << "6. Recorridos\n";
        cout << "7. Salir\n";
        cout << "Seleccione una opción: ";
        cin >> opcion;

        switch (opcion) {
            case 1: { //NO CAMBIAR - DAYANA
                if (ii < generaciones) {
                    int id, nac;
                    string nombre, fallecido;
                    cout << "ID (DNI): "; cin >> id;
                    cin.ignore();
                    cout << "Nombre: "; getline(cin, nombre);
                    cout << "Año de nacimiento: "; cin >> nac;
                    cin.ignore();
                    cout << "Fallecimiento (o 'Vivo'): "; getline(cin, fallecido);
                    Nodo* nuevo = crearNodo(id, nombre, nac, fallecido);
                    insertarFlexible(raiz, nuevo);
                    ii++;
                } else {
                    cout << "Ya ingresó el número máximo de miembros.\n";
                }
            break;

            case 2: {
                int id;
                cout << "Ingrese ID a buscar: ";
                cin >> id;
                Nodo* resultado = buscar(raiz, id);
                if (resultado)
                    cout << "Encontrado: " << resultado->nombre << " (" << resultado->id << ")\n";
                else
                    cout << "No encontrado.\n";
                break;
            }

            case 3: {
                int id;
                cout << "ID a eliminar: ";
                cin >> id;
                raiz = eliminar(raiz, id);
                cout << "Eliminado si existía.\n";
                break;
            }

            case 4: {
                int id;
                cout << "ID para ver ancestros: ";
                cin >> id;
                Nodo* n = buscar(raiz, id);
                if (n) mostrarAncestros(n->padre);
                else cout << "No encontrado.\n";
                break;
            }

            case 5: {
                int id;
                cout << "ID para ver descendientes: ";
                cin >> id;
                Nodo* n = buscar(raiz, id);
                if (n) mostrarDescendientes(n);
                else cout << "No encontrado.\n";
                break;
            }

            case 6: {
                int tipo;
                cout << "1. Inorden\n2. Preorden\n3. Postorden\n4. Por niveles\nOpción: ";
                cin >> tipo;
                switch (tipo) {
                    case 1: inorden(raiz); break;
                    case 2: preorden(raiz); break;
                    case 3: postorden(raiz); break;
                    case 4: porNiveles(raiz); break;
                    default: cout << "Opción no válida.\n"; break;
                }
                break;
            }

            case 7:
                cout << "Programa finalizado.\n";
                break;

            default:
                cout << "Opción inválida. Intente de nuevo.\n";
                break;
        }

    } while (opcion != 7);

    return 0;
}
