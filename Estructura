#include <iostream>
#include <string>
using namespace std;

struct Nodo {
    int id;
    string nombre;
    int nacimiento;
    string fallecimiento;
    Nodo* izq;
    Nodo* der;
    Nodo* padre;
};

Nodo* raiz = NULL;

// Crear nuevo nodo
Nodo* crearNodo(int id, string nombre, int nacimiento, string fallecimiento) {
    Nodo* nuevo = new Nodo;
    nuevo->id = id;
    nuevo->nombre = nombre;
    nuevo->nacimiento = nacimiento;
    nuevo->fallecimiento = fallecimiento;
    nuevo->izq = nuevo->der = nuevo->padre = NULL;
    return nuevo;
}

// Buscar miembro por ID
Nodo* buscar(Nodo* actual, int id) {
    if (actual == NULL || actual->id == id) return actual;
    return (id < actual->id) ? buscar(actual->izq, id) : buscar(actual->der, id);
}
//Buscar Mienbro por nombre
Nodo* buscarPorNombre(Nodo* nodo, string nombre) {
    if (!nodo) return NULL;
    if (nodo->nombre == nombre) return nodo;

    Nodo* izq = buscarPorNombre(nodo->izq, nombre);
    if (izq) return izq;

    return buscarPorNombre(nodo->der, nombre);
}

// Insertar miembro
void insertarFlexible(Nodo*& raiz, Nodo* nuevo, int generacionesMax, int idRelacionado, int relacion) { //NO CAMBIAR - DAYANA
	Nodo* relativo = buscar(raiz, idRelacionado);
	if (!relativo) {
	    cout << "Miembro no encontrado.\n";
	    return;
	}

    switch (relacion) {
		case 1:
            if (relativo == raiz) {
                nuevo->izq = raiz;
                raiz->padre = nuevo;
                raiz = nuevo;
            } else {
                Nodo* padreAnt = relativo->padre;
                nuevo->padre = padreAnt;
                relativo->padre = nuevo;
                if (padreAnt) {
                    if (padreAnt->izq == relativo) padreAnt->izq = nuevo;
                    else padreAnt->der = nuevo;
                }
                nuevo->izq = relativo;
            }
            cout << "Asignado como padre/madre.\n";
            break;
        case 2:
            if (!relativo->izq) {
                relativo->izq = nuevo;
                nuevo->padre = relativo;
                cout << "Asignado como hijo izquierdo.\n";
            } else cout << "Ya tiene hijo izquierdo.\n";
            break;
        case 3:
            if (!relativo->der) {
                relativo->der = nuevo;
                nuevo->padre = relativo;
                cout << "Asignado como hijo derecho.\n";
            } else cout << "Ya tiene hijo derecho.\n";
            break;
		case 4:
		    if (!relativo->padre) {
		        cout << "No tiene padre registrado, no se puede agregar hermano.\n";
		        break;
		    }
		    if (relativo->padre->izq == NULL) {
		        relativo->padre->izq = nuevo;
		        nuevo->padre = relativo->padre;
		        cout << "Asignado como hermano izquierdo.\n";
		    } else {
		        cout << "Ya existe un hijo izquierdo, no se puede agregar como hermano.\n";
		    }
		    break;
		
		case 5:
		    if (!relativo->padre) {
		        cout << "No tiene padre registrado, no se puede agregar hermano.\n";
		        break;
		    }
		    if (relativo->padre->der == NULL) {
		        relativo->padre->der = nuevo;
		        nuevo->padre = relativo->padre;
		        cout << "Asignado como hermano derecho.\n";
		    } else {
		        cout << "Ya existe un hijo derecho, no se puede agregar como hermano.\n";
		    }
		    break;

        default:
            cout << "Relación no válida.\n";
    }
}

// Mínimo del subárbol
Nodo* minimo(Nodo* actual) {
    while (actual && actual->izq != NULL)
        actual = actual->izq;
    return actual;
}

void eliminarMiembroGenealogico(Nodo*& raiz, int id) {
    Nodo* actual = buscar(raiz, id); // 1. Buscar al miembro a eliminar por su ID
    if (!actual) {
        cout << "Miembro no encontrado.\n"; // 2. Si no lo encuentra, muestra mensaje
        return;
    }

    Nodo* padre = actual->padre; // 3. Guardamos al padre del nodo a eliminar (si tiene)

    // 4. Si tiene un padre (NO es la raíz)
    if (padre) {
        if (padre->izq == actual) { // 5. ¿Es hijo izquierdo?
            // 6. Asignamos el hijo izquierdo del eliminado como nuevo hijo del padre
            padre->izq = actual->izq ? actual->izq : actual->der;
            if (padre->izq) padre->izq->padre = padre;
        } else if (padre->der == actual) { // 7. ¿Es hijo derecho?
            padre->der = actual->izq ? actual->izq : actual->der;
            if (padre->der) padre->der->padre = padre;
        }

    } else {
        // 8. Si el nodo a eliminar es la raíz (NO tiene padre)
        if (actual->izq) {
            raiz = actual->izq;         // 9. Su hijo izquierdo será la nueva raíz
            raiz->padre = NULL;

            // 10. Si también hay hijo derecho, lo colocamos como descendiente
            Nodo* temp = raiz;
            while (temp->der) temp = temp->der;  // 11. Buscamos la posición más a la derecha
            temp->der = actual->der;             // 12. Lo colocamos allí
            if (actual->der) actual->der->padre = temp;

        } else if (actual->der) {
            raiz = actual->der;  // 13. Si no tiene hijo izquierdo, el derecho será la raíz
            raiz->padre = NULL;
        } else {
            raiz = NULL;  // 14. Si no tiene hijos, el árbol queda vacío
        }
    }

    delete actual;  // 15. Finalmente, eliminamos el nodo
    cout << "Miembro eliminado correctamente (con reorganización).\n";
}

//imprimir recorrido con datos completos
void imprimirFicha(Nodo* nodo, const string& tipo) {
    cout << "\t----------------------------------\n";
    cout << "\tTipo      : " << tipo << "\n";
    cout << "\tNombre    : " << nodo->nombre << "\n";
    cout << "\tID (DNI)  : " << nodo->id << "\n";
    cout << "\tNacimiento: " << nodo->nacimiento << "\n";
    cout << "\tFallecido : " << nodo->fallecimiento << "\n";
}

// Recorridos
void inorden(Nodo* nodo, string tipo = "RAIZ") {
    if (!nodo) return;
    inorden(nodo->izq, "Hijo Izquierdo");
    imprimirFicha(nodo, tipo);
    inorden(nodo->der, "Hijo Derecho");
}

void preorden(Nodo* nodo, string tipo = "RAÍZ") {
    if (!nodo) return;
    imprimirFicha(nodo, tipo);
    preorden(nodo->izq, "Hijo Izquierdo");
    preorden(nodo->der, "Hijo Derecho");
}

void postorden(Nodo* nodo, string tipo = "RAÍZ") {
    if (!nodo) return;
    postorden(nodo->izq, "Hijo Izquierdo");
    postorden(nodo->der, "Hijo Derecho");
    imprimirFicha(nodo, tipo);
}

void porNiveles(Nodo* raiz) {
    if (raiz == NULL) return;

    const int MAX = 100;
    Nodo* cola[MAX];
    int inicio = 0, fin = 0;

    // Encolar raíz
    cola[fin++] = raiz;

    while (inicio < fin) {
        Nodo* actual = cola[inicio++]; // Desencolar

        imprimirFicha(actual, "Pariente");

        // Encolar hijos
        if (actual->izq != NULL) {
            cola[fin++] = actual->izq;
        }
        if (actual->der != NULL) {
            cola[fin++] = actual->der;
        }
    }
}

// Ancestros
void mostrarAncestros(Nodo* ancestro, Nodo* hijoOriginal) {
    if (ancestro == NULL) {
        cout << "\n\tEste nodo no tiene ancestros registrados.\n";
        return;
    }

    int nivel = 1;
    while (ancestro) {
        cout << "\n\tNivel " << nivel << " - Ancestro:\n";
        imprimirFicha(ancestro, "Ancestro");

        int diferencia = (hijoOriginal->nacimiento > ancestro->nacimiento) 
                    ? (hijoOriginal->nacimiento - ancestro->nacimiento) 
                    : (ancestro->nacimiento - hijoOriginal->nacimiento);
        cout << "\tDiferencia de nacimiento con respecto a " << hijoOriginal->nombre
             << ": " << diferencia << " años\n";

        ancestro = ancestro->padre;
        nivel++;
    }
}

// Descendientes (en preorden)
void mostrarDescendientes(Nodo* nodo) {
    if (!nodo) return;

    // Verificamos si el nodo no tiene hijos
    if (nodo->izq == NULL && nodo->der == NULL) {
        cout << "\n\tEste nodo no tiene hijos (hojas).\n";
        return;
    }

    // Si tiene hijos, los mostramos con sus respectivos recorridos
    if (nodo->izq) {
        imprimirFicha(nodo->izq, "Descendiente (izquierdo)");
        mostrarDescendientes(nodo->izq);
    }
    if (nodo->der) {
        imprimirFicha(nodo->der, "Descendiente (derecho)");
        mostrarDescendientes(nodo->der);
    }
}

int calcularNivel(Nodo* nodo) {
    int nivel = 1;
    while (nodo->padre != NULL) {
        nivel++;
        nodo = nodo->padre;
    }
    return nivel;
}

int calcularProfundidad(Nodo* nodo, int nivel) {
    if (nodo == NULL) return nivel - 1;
    int izq = calcularProfundidad(nodo->izq, nivel + 1);
    int der = calcularProfundidad(nodo->der, nivel + 1);
    return (izq > der) ? izq : der;
}

bool validaranio(Nodo* nuevo, Nodo* relativo, int relacion){
	int diferencia;

    switch (relacion) {
        case 1: { // Padre / madre
            diferencia = relativo->nacimiento - nuevo->nacimiento;
            if (diferencia < 12) { //si la diferencia de la edad del hijo(relativo) - la edad de la raiz(nuevo) es menor a 12...
                cout << "\tError: Es muy joven para ser padre/madre de " << relativo->nombre << ".\n";
                return false;
            }
            return true; //continua y valida la edad en caso de que el padre si sea mayor o igual a 12 años
        }
		//si la edad del nuevo ingresante - el del relativo es menor a 12 también decimos que al diferencia de edad no es valida
        case 2: // Hijo izquierdo
        case 3: { // Hijo derecho
            diferencia = nuevo->nacimiento - relativo->nacimiento;
            if (diferencia < 12) {
                cout << "\n\tError: muy poca diferencia de edad para ser hijo/a de " << relativo->nombre << ".\n";
                return false;
            }
            return true; //si la edad es valida continuamos
        }
		//la diferencia de edad entre el nuevo miembro y la Raiz es mayor a 40
        case 4: // Hermano izquierdo
        case 5: { // Hermano derecho
            diferencia = nuevo->nacimiento - relativo->nacimiento;
            if (diferencia > 40) { //decimos que hay un error ya que no siempre la edad es tan diferente
                cout << "\n\tError: demasiada diferencia de edad para ser hermanos.\n";
                return false;
            }
            return true; //si está dentro del rango etonces continuamos
        }

        default: //si no cumple ninguno de esos casos decimos que no es válida la relación
            cout << "\tRelación no válida.\n";
            return false;
    }
}

// Menú principal
int main() {
    setlocale(LC_CTYPE, "Spanish");
    int generaciones;
	cout << "\n\tIngrese cuántas generaciones máximas tendrá el árbol genealógico: ";
	cin >> generaciones;

    int opcion;
    do {
	cout << "\n\t----------------------------------\n";
        cout << "\t|---- MENU ÁRBOL GENEALÓGICO ----|\n";
	cout << "\t----------------------------------\n";
        cout << "\n\t[1]. Insertar miembro\n";
        cout << "\t[2]. Buscar miembro\n";
        cout << "\t[3]. Eliminar miembro\n";
        cout << "\t[4]. Consultar ancestros\n";
        cout << "\t[5]. Consultar descendientes\n";
        cout << "\t[6]. Recorridos\n";
        cout << "\t[7]. Salir\n";
        cout << "\n\tSeleccione una opción: ";
        cin >> opcion;

        switch (opcion) {
			case 1: {
			    if (!raiz) {
			        int id, nac;
			        string nombre, fallecido;
			
			        cout << "\tID (DNI)\t\t: "; cin >> id;
			        cout << "\tNombre\t\t\t: "; cin >> nombre;
			        cout << "\tAño de nacimiento\t: "; cin >> nac;
			        cout << "\tFallecimiento (o 'Vivo'): "; cin >> fallecido;
			
			        Nodo* nuevo = crearNodo(id, nombre, nac, fallecido);
			        raiz = nuevo;
			        cout << "\tPrimer miembro insertado como raíz.\n";
			    } else {
			        int idRelacionado, relacion;
			
			        cout << "\n\tIngrese el ID del familiar relacionado: ";
			        cin >> idRelacionado;
			
			        Nodo* relativo = buscar(raiz, idRelacionado);
			        if (!relativo) {
			            cout << "\tMiembro no encontrado.\n";
			            break;
			        }
			
			        cout << "\n\t¿Qué relación tiene con " << relativo->nombre << "?\n";
			        cout << "\n\t1 -> Padre/Madre\n";
			        cout << "\t2 -> Hijo/a izquierdo/a\n";
			        cout << "\t3 -> Hijo/a derecho/a\n";
			        cout << "\t4 -> Hermano/a izquierdo/a\n";
			        cout << "\t5 -> Hermano/a derecho/a\n";
			        cout << "\n\tDigite un número de opción: ";
			        cin >> relacion;
			
			        // Verifica si excede generaciones antes de pedir datos
					int nivelActual = calcularNivel(relativo);
					if ((relacion == 1 && nivelActual >= generaciones) || // Insertar padre sube una generación
					    ((relacion == 2 || relacion == 3) && nivelActual + 1 > generaciones) || // Insertar hijo sí sube
					    ((relacion == 4 || relacion == 5) && nivelActual > generaciones)) { // Hermano está al mismo nivel
					    cout << "\tNo se puede insertar: excede las generaciones permitidas.\n";
					    break;
					}
			
			        // Ahora sí pide los datos del nuevo miembro
			        int id, nac;
			        string nombre, fallecido;
			
			        cout << "\tID (DNI)\t\t: "; cin >> id;
			        cout << "\tNombre\t\t\t: "; cin >> nombre;
			        cout << "\tAño de nacimiento\t: "; cin >> nac;
			        cout << "\tFallecimiento (o 'Vivo'): "; cin >> fallecido;
			
			        Nodo* nuevo = crearNodo(id, nombre, nac, fallecido);
				if (!validaranio(nuevo, relativo, relacion)) {
    					cout << "\tNo se puede insertar: años de nacimiento INCOHERENTES para la relación indicada.\n";
    					break;
				}
			        insertarFlexible(raiz, nuevo, generaciones, idRelacionado, relacion);
			    }
			    break;
			}

            case 2: {
                int id;
                cout << "\n\tIngrese ID a buscar: ";
                cin >> id;
                Nodo* resultado = buscar(raiz, id);
                if (resultado)
                    cout << "\tEncontrado: " << resultado->nombre << " (" << resultado->id << ")\n";
                else
                    cout << "\tNo encontrado.\n";
                break;
            }

            case 3: {
		int id;
		cout << "\tID a eliminar (por fallecimiento): ";
		cin >> id;
		eliminarMiembroGenealogico(raiz, id);
	        break;
	    }

            case 4: {
                int tipoBusqueda;
                cout << "\n\t¿Cómo desea buscar al miembro?\n";
                cout << "\t[1] Por ID\n";
                cout << "\t[2] Por nombre\n";
                cout << "\tSeleccione una opción: ";
                cin >> tipoBusqueda;

                Nodo* n = NULL;
                if (tipoBusqueda == 1) {
                    int id;
                    cout << "\tIngrese ID para ver ancestros: ";
                    cin >> id;
                    n = buscar(raiz, id);
                } else if (tipoBusqueda == 2) {
                    string nombre;
                    cout << "\tIngrese nombre exacto para ver ancestros: ";
                    cin >> nombre;
                    n = buscarPorNombre(raiz, nombre);
                } else {
                    cout << "\tOpción inválida.\n";
                    break;
                }

                if (n)
                     mostrarAncestros(n->padre, n);
                else
                    cout << "\tMiembro no encontrado.\n";

                break;
            }

            case 5: {
                int tipoBusqueda;
                cout << "\n\t¿Cómo desea buscar al miembro?\n";
                cout << "\t[1] Por ID\n";
                cout << "\t[2] Por nombre\n";
                cout << "\tSeleccione una opción: ";
                cin >> tipoBusqueda;

                Nodo* n = NULL;
                if (tipoBusqueda == 1) {
                    int id;
                    cout << "\tIngrese ID para ver descendientes: ";
                    cin >> id;
                    n = buscar(raiz, id);
                } else if (tipoBusqueda == 2) {
                    string nombre;
                    cout << "\tIngrese nombre exacto para ver descendientes: ";
                    cin >> nombre;
                    n = buscarPorNombre(raiz, nombre);
                } else {
                    cout << "\tOpción inválida.\n";
                    break;
                }

                if (n)
                    mostrarDescendientes(n);
                else
                    cout << "\tMiembro no encontrado.\n";

                break;
            }

            case 6: {
                int tipo;
                cout << "\n\t1. Inorden\n\t2. Preorden\n\t3. Postorden\n\t4. Por niveles\n\n\tOpción: ";
                cin >> tipo;
                switch (tipo) {
                    case 1:
			cout << "\n\t========= RECORRIDO EN INORDEN =========\n";
			inorden(raiz); break;
                    case 2:
                    	cout << "\n\t========= RECORRIDO EN PREORDEN =========\n";
			preorden(raiz); break;
                    case 3:
                    	cout << "\n\t========= RECORRIDO EN POSTORDEN =========\n";
			postorden(raiz); break;
                    case 4:
                    	cout << "\n\t========= RECORRIDO POR NIVELES =========\n";
			porNiveles(raiz); break;
                    default: cout << "\n\tOpción no válida.\n"; break;
                }
                break;
            }

            case 7:
                cout << "\tPrograma finalizado.\n";
                break;

            default:
                cout << "\tOpción inválida. Intente de nuevo.\n";
                break;
        }

    } while (opcion != 7);

    return 0;
}
